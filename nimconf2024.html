<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/reveal.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/theme/black.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/highlight/monokai.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  </head>
  <body>
  <div class="reveal">
    <div class="slides">
      <section data-nimib-slide-number="1" >
      <h1>Karax, Kraut, Karkas</h1>
<p>Create compact, fast, and composable frontend and have fun doing it</p>
      <aside class="notes">
  <p>Hi! My name is Constantine, and I've been using Nim as my primary language for hobby development for over a decade.</p>
<p>Today, I'd like to talk about applying Nim in frontend development. My goal is to show that Nim isn't just a viable option for frontend development (this is not news) but an option you can actually compare to the mainstream frameworks like React or Vue in terms of usability, reusability, app size, and programmer's experience.</p>

</aside>
      </section>
      <section data-nimib-slide-number="2" >
      <h2>Key Points</h2>
<ol>
<li>
<p><a href="https://github.com/karaxnim/karax"><strong>Karax</strong></a> is a great framework: fast, lightweight, stable. But it lacks some sugar, namely routing and components.</p>
</li>
<li>
<p><a href="https://github.com/moigagoo/kraut"><strong>Kraut</strong></a> is the missing routing layer for Karax.</p>
<ul>
<li><a href="https://github.com/moigagoo/sauer"><strong>Sauer</strong></a> is a helper CLI tool that makes adding routes trivial.</li>
</ul>
</li>
<li>
<p><a href="https://karkas.nim.town/"><strong>Karkas</strong></a> is the missing component and layouting layer for Karax.</p>
</li>
</ol>
      <aside class="notes">
  <p>First off, Nim has had a React-like framework for ages, called Karax. It's a lean, robust, and mature framework. It produces tiny bundles and is production-ready. However, to compete against React, it lacks some sugar to make a developer's life easier. To me, the most critical ones were routing and components.</p>
<p>This is why I wrote Kraut (along with its companion app Sauer) and Karkasâ€”respectively, the missing routing and component layers for Karax.</p>

</aside>
      </section>
      <section data-nimib-slide-number="3" data-auto-animate >
      <h2>Karax</h2>
      <figure>
<img src="/img/screwdriver.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="4" data-auto-animate >
      <h2>Karax</h2>
      <ul>
<li>
<p>Virtual DOM implementation</p>
<ul>
<li>Write functions to run in a tight loop to redraw the page</li>
</ul>
</li>
<li>
<p>DSL to build web pages</p>
<ul>
<li>Use familiar tag names without HTML noise</li>
</ul>
</li>
<li>
<p>VNode type that incapsulates a renderable chunk</p>
<ul>
<li>Essentially a component</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="5" data-auto-animate >
      <h2>Karax</h2>
      <pre><code class="language-nim">include karax/prelude

proc render(routerData: RouterData): VNode =
  buildHtml:
    tdiv:
      h1:
        text &quot;Header&quot;
      p:
        text &quot;You're at &quot; &amp; $routerData.hashPart

setRenderer render
</code></pre>
<pre><code class="language-shell">$ karun app.nim
</code></pre>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="6" data-auto-animate >
      <h2>Karax</h2>
      <figure>
<img src="/img/karax_app.png" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="7" data-auto-animate >
      <h2>Kraut</h2>
      <figure>
<img src="/img/screwdriver_with_heads.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="8" data-auto-animate >
      <h2>Kraut</h2>
      <ul>
<li>
<p>Parser and matcher for Karax's <code>hashPart</code></p>
<ul>
<li>Define routes as string templates matched against the current <code>hashPart</code> value</li>
</ul>
</li>
<li>
<p>Familiar renderer functions from Karax</p>
<ul>
<li>Just return a <code>VNode</code> somehow</li>
</ul>
</li>
<li>
<p>Query and URL param support</p>
<ul>
<li>Access captured context in <code>Context</code> object</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="9" data-auto-animate >
      <h2>Kraut</h2>
      <pre><code class="language-nim">proc renderUser*(context: Context): VNode =
  buildHtml:
    tdiv:
      p:
        text &quot;User id: &quot; &amp; context.urlParams[&quot;userId&quot;]
</code></pre>
<pre><code class="language-nim">include karax/prelude
import kraut


const
  routes = {
    &quot;/&quot;: renderIndex,
    &quot;/users/&quot;: renderUsers,
    &quot;/users/{userId}/&quot;: renderUser
  }

setRenderer routeRenderer(routes)
</code></pre>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="10" data-auto-animate >
      <h2>Kraut</h2>
      <figure>
<img src="/img/kraut_app.png" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="11" data-auto-animate >
      <h2>Sauer</h2>
      <figure>
<img src="/img/screwdriver_box.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>By allowing us to separate route definition and processing, Kraut paves the way for having a standardized routing convention. This convention is implenented by Kraut's companion app Sauer.</p>
<p>Sauer is a command-line app for Karax project setup with a certain code structure. It also allows you to add new routes quickly.</p>
<p>Sauer introduces a new abstraction called Page. Page represents a location that has a route. It maps naturally to your app business logic. For example, you can have a page for the user profile, a page for the shopping cart, and a search page.</p>
<p>Another addition that Sauer makes is that it creates a state module in your app. It's a module that holds the global state of your app, allowing you to pass the data around across modules. Really simple solution but works really well.</p>
<p>Here're some quick examples of Sauer commands and the code they produce.</p>
<p>Notice that we use the global state to store the current page. This is just one example if the data we can store there.</p>

</aside>
      </section>
      <section data-nimib-slide-number="12" data-auto-animate >
      <h2>Sauer</h2>
      <ul>
<li>
<p>Standardized app structure</p>
<ul>
<li>Init project and add pages with shell commands</li>
</ul>
</li>
<li>
<p><strong>Page</strong> abstraction that represents anything that has its own route</p>
<ul>
<li>Focus on business logic</li>
</ul>
</li>
<li>
<p>Global state</p>
<ul>
<li>Access the current page from <code>state</code> module</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>By allowing us to separate route definition and processing, Kraut paves the way for having a standardized routing convention. This convention is implenented by Kraut's companion app Sauer.</p>
<p>Sauer is a command-line app for Karax project setup with a certain code structure. It also allows you to add new routes quickly.</p>
<p>Sauer introduces a new abstraction called Page. Page represents a location that has a route. It maps naturally to your app business logic. For example, you can have a page for the user profile, a page for the shopping cart, and a search page.</p>
<p>Another addition that Sauer makes is that it creates a state module in your app. It's a module that holds the global state of your app, allowing you to pass the data around across modules. Really simple solution but works really well.</p>
<p>Here're some quick examples of Sauer commands and the code they produce.</p>
<p>Notice that we use the global state to store the current page. This is just one example if the data we can store there.</p>

</aside>
      </section>
      <section data-nimib-slide-number="13" data-auto-animate >
      <h2>Sauer</h2>
      <pre><code class="language-shell">$ sauer init
$ sauer pages new user --route='/users/{userId}/'
</code></pre>
<pre><code class="language-nim">include karax/prelude
import kraut

import ../[pages, state]


proc render*(context: Context): VNode =
  currentPage = Page.user
  document.title = &quot;user&quot;

  buildHtml:
    h1: text &quot;user&quot;
</code></pre>
      <aside class="notes">
  <p>By allowing us to separate route definition and processing, Kraut paves the way for having a standardized routing convention. This convention is implenented by Kraut's companion app Sauer.</p>
<p>Sauer is a command-line app for Karax project setup with a certain code structure. It also allows you to add new routes quickly.</p>
<p>Sauer introduces a new abstraction called Page. Page represents a location that has a route. It maps naturally to your app business logic. For example, you can have a page for the user profile, a page for the shopping cart, and a search page.</p>
<p>Another addition that Sauer makes is that it creates a state module in your app. It's a module that holds the global state of your app, allowing you to pass the data around across modules. Really simple solution but works really well.</p>
<p>Here're some quick examples of Sauer commands and the code they produce.</p>
<p>Notice that we use the global state to store the current page. This is just one example if the data we can store there.</p>

</aside>
      </section>
      <section data-nimib-slide-number="14" data-auto-animate >
      <h2>Karkas</h2>
      <figure>
<img src="/img/electric_screwdriver.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="15" data-auto-animate >
      <h2>Karkas</h2>
      <ul>
<li>
<p>Additional sugar for VNode styling</p>
<ul>
<li>Type less stuff to please the compiler</li>
</ul>
</li>
<li>
<p>Unified approach to components</p>
<ul>
<li>Svelte-like all-in-one components</li>
<li>Layouts are components, too</li>
</ul>
</li>
<li>
<p>Building blocks for layouts</p>
<ul>
<li>Construct pages with flexbox-based primitives</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="16" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">include karax/prelude
import karkas

import ../[pages, state]


proc navEntry(page: Page, url, caption: string): VNode =
  buildHtml:
    tdiv(style = box() &lt;- {minWidth: &quot;50px&quot;}):
      if state.currentPage != page:
        a(href = k url):
          text k caption
      else:
        text k caption
</code></pre>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="17" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">const
  topPanelStyle = {padding: &quot;10px&quot;, boxShadow: &quot;0 0 10px&quot;}

proc render*(body: VNode): VNode =
  buildHtml:
    tdiv(style = vStack()):
      tdiv(style = topPanel() &lt;- hStack() &lt;- topPanelStyle):
        navEntry(index, &quot;#/&quot;, &quot;Home&quot;)
        navEntry(user, &quot;#/user&quot;, &quot;User&quot;)
      tdiv:
        for node in body:
          node
</code></pre>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="18" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">include karax/prelude
import kraut

import ../[pages, state, layout]


proc render*(context: Context): VNode =
  currentPage = Page.user
  document.title = &quot;user&quot;

  layout.render buildHtml(tdiv) do:
    h1: text &quot;user&quot;
</code></pre>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="19" data-auto-animate >
      <h2>Karkas</h2>
      <figure>
<img src="/img/karkas_app.gif" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Thanks to Sauer and Kraut's higher level abstractions and enforced code structure, we can actually have a component system.</p>
<p>This is where Karkas enters the stage. It's package that helps create components.</p>
<p>First, Karkas gives you syntax sugar to apply styles to VNodes. While Karax offeres VNode styling by default, its usage requires a lot of redundant typing and type conversion to please the compiler.</p>
<p>With this sugar, you can create self-contained Svelte-like components.</p>
<p>Finally, there's sugar for layouting, based on flexbox.</p>
<p>Here's a sample app generated with Sauer, and layouted with Karkas. You can find the complete code on GitHub.</p>
<p>First, check out how we create an isolated navigation entry component. Notice that it knows how to render itself based on whether it represents the currently opened page or not.</p>
<p>Also, you can spot Karkas's arrow proc that converts sequences to VStyles and merges multiple styles together.</p>
<p>Another interesting proc is k. It simply converts a string into a kstring, saving you typing.</p>
<p>Next, let's look at the layout. This one has its styles stored in a separate value and then applied after Karkas's built-in layouting presets for top panel and horizontal stack.</p>
<p>Notice how we make a component render other components: we simply pass a VNode and iterate over its children.</p>
<p>Finally, here's the page code. We now render its content inside the layout component, which ensures every page gets a nice navigation bar. This is done with a simple do notation trick.</p>
<p>Here's how the end result looks like. You can see our app using standard layout across pages and correctly reacting to navigation.</p>

</aside>
      </section>
      <section data-nimib-slide-number="20" data-auto-animate >
      <h2>The End</h2>
      <ul>
<li>Live app example: <a href="https://app.cannon-chat.online">app.cannon-chat.online</a></li>
<li>Demo apps: <a href="https://github.com/moigagoo/nimconf2024/tree/develop/demo">github.com/moigagoo/nimconf2024/tree/develop/demo</a></li>
<li>Kraut: <a href="https://github.com/moigagoo/kraut">github.com/moigagoo/kraut</a></li>
<li>Sauer: <a href="https://github.com/moigagoo/sauer">github.com/moigagoo/sauer</a></li>
<li>Karkas: <a href="https://karkas.nim.town">karkas.nim.town</a></li>
</ul>
      
      
      <aside class="notes">
  <p>And this is the end of my talk! Here are some links to help you expore the topic further:</p>
<ul>
<li>Cannon chat web app UI is created with Nim entirely using the tools described in the presentation.</li>
<li>You'll find the complete demo app code in the presentation repo on GitHub.</li>
<li>Finally, here're the links to Kraut, Sauer, and Karkas. Please use them, send PR, and report issues.</li>
</ul>
<p>Thanks!</p>

</aside>
      </section>
      <script defer>/* Generated by the Nim Compiler v2.0.8 */
var framePtr = null;
var excHandler = 0;
var lastJSError = null;

function toJSStr(s_33556901) {
  var result_33556902 = null;

    var res_33556943 = newSeq_33556919((s_33556901).length);
    var i_33556944 = 0;
    var j_33556945 = 0;
    Label1: {
        Label2: while (true) {
        if (!(i_33556944 < (s_33556901).length)) break Label2;
          var c_33556946 = s_33556901[i_33556944];
          if ((c_33556946 < 128)) {
          res_33556943[j_33556945] = String.fromCharCode(c_33556946);
          i_33556944 += 1;
          }
          else {
            var helper_33556959 = newSeq_33556919(0);
            Label3: {
                Label4: while (true) {
                if (!true) break Label4;
                  var code_33556960 = c_33556946.toString(16);
                  if ((((code_33556960) == null ? 0 : (code_33556960).length) == 1)) {
                  helper_33556959.push("%0");;
                  }
                  else {
                  helper_33556959.push("%");;
                  }
                  
                  helper_33556959.push(code_33556960);;
                  i_33556944 += 1;
                  if ((((s_33556901).length <= i_33556944) || (s_33556901[i_33556944] < 128))) {
                  break Label3;
                  }
                  
                  c_33556946 = s_33556901[i_33556944];
                }
            };
++excHandler;
            try {
            res_33556943[j_33556945] = decodeURIComponent(helper_33556959.join(""));
--excHandler;
} catch (EXCEPTION) {
 var prevJSError = lastJSError;
 lastJSError = EXCEPTION;
 --excHandler;
            res_33556943[j_33556945] = helper_33556959.join("");
            lastJSError = prevJSError;
            } finally {
            }
          }
          
          j_33556945 += 1;
        }
    };
    if (res_33556943.length < j_33556945) { for (var i = res_33556943.length ; i < j_33556945 ; ++i) res_33556943.push(null); }
               else { res_33556943.length = j_33556945; };
    result_33556902 = res_33556943.join("");

  return result_33556902;

}

function rawEcho() {
          var buf = "";
      for (var i = 0; i < arguments.length; ++i) {
        buf += toJSStr(arguments[i]);
      }
      console.log(buf);
    

  
}
var objectID_721420465 = [0];

function newSeq_33556919(len_33556921) {
  var result_33556922 = [];

    result_33556922 = new Array(len_33556921); for (var i = 0 ; i < len_33556921 ; ++i) { result_33556922[i] = null; }
  return result_33556922;

}

function find_536870955(a_536870958, item_536870959) {
  var result_536870960 = 0;

  BeforeRet: {
    result_536870960 = 0;
    Label1: {
      var i_536870974 = null;
      var i_536871116 = 0;
      Label2: {
          Label3: while (true) {
          if (!(i_536871116 < (a_536870958).length)) break Label3;
            i_536870974 = a_536870958[i_536871116];
            if ((i_536870974 == item_536870959)) {
            break BeforeRet;
            }
            
            result_536870960 += 1;
            i_536871116 += 1;
          }
      };
    };
    result_536870960 = (-1);
  };

  return result_536870960;

}

function contains_536870950(a_536870952, item_536870953) {
  var result_536870954 = false;

  BeforeRet: {
    result_536870954 = (0 <= find_536870955(a_536870952, item_536870953));
    break BeforeRet;
  };

  return result_536870954;

}

function HEX3Aanonymous_536870937(eventHEX60gensym0_536870938) {
    
function HEX3Aanonymous_536870941(event_536870942) {
      BeforeRet: {
        rawEcho([115,108,105,100,101,99,104,97,110,103,101,100,33]);
        var currentSlide_536870943 = event_536870942.currentSlide;
        console.log(currentSlide_536870943);
        Label1: {
          var node_536870947 = null;
          var i_536871111 = 0;
          var L_536871112 = (currentSlide_536870943.attributes).length;
          Label2: {
              Label3: while (true) {
              if (!(i_536871111 < L_536871112)) break Label3;
                node_536870947 = currentSlide_536870943.attributes[i_536871111];
                if (contains_536870950(["data-background-video", "data-background-iframe", "data-background-image"], node_536870947.nodeName)) {
                footer_536870940.style.setProperty("visibility", "hidden", []);
                break BeforeRet;
                }
                
                i_536871111 += 1;
              }
          };
        };
        footer_536870940.style.setProperty("visibility", "visible", []);
      };

      
    }
      
function HEX3Aanonymous_536871012(eventHEX60gensym0_536871013) {
          
function HEX3Aanonymous_536871016(event_536871017) {
            BeforeRet: {
              rawEcho([115,108,105,100,101,99,104,97,110,103,101,100,33]);
              var currentSlide_536871018 = event_536871017.currentSlide;
              console.log(currentSlide_536871018);
              Label1: {
                var node_536871022 = null;
                var i_536871119 = 0;
                var L_536871120 = (currentSlide_536871018.attributes).length;
                Label2: {
                    Label3: while (true) {
                    if (!(i_536871119 < L_536871120)) break Label3;
                      node_536871022 = currentSlide_536871018.attributes[i_536871119];
                      if (contains_536870950(["data-background-video", "data-background-iframe", "data-background-image"], node_536871022.nodeName)) {
                      footer_536871015.style.setProperty("visibility", "hidden", []);
                      break BeforeRet;
                      }
                      
                      i_536871119 += 1;
                    }
                };
              };
              footer_536871015.style.setProperty("visibility", "visible", []);
            };

            
          }

          rawEcho([68,111,105,110,103,32,115,111,109,101,116,104,105,110,103,33]);
          var deck_536871014 = Reveal.getRevealElement();
          var footer_536871015 = document.getElementById("reveal-footer").cloneNode(true);
          footer_536871015.style.setProperty("visibility", "visible", []);
          deck_536871014.appendChild(footer_536871015);
          Reveal.on("slidechanged", HEX3Aanonymous_536871016);

        
      }

    if (Reveal.isReady()) {
    rawEcho([68,111,105,110,103,32,115,111,109,101,116,104,105,110,103,33]);
    var deck_536870939 = Reveal.getRevealElement();
    var footer_536870940 = document.getElementById("reveal-footer").cloneNode(true);
    footer_536870940.style.setProperty("visibility", "visible", []);
    deck_536870939.appendChild(footer_536870940);
    Reveal.on("slidechanged", HEX3Aanonymous_536870941);
    }
    else {
    Reveal.on("ready", HEX3Aanonymous_536871012);
    }
    

  
}
rawEcho([66,101,102,111,114,101]);
window.addEventListener("load", HEX3Aanonymous_536870937, false);
</script>
    </div>
    <div id="reveal-footer" style="position: absolute; text-align: center; width: 100%; bottom: 0%; visibility: hidden; opacity: 0.6; font-size: 20px">
      <p>Slides online: <a href="https://moigagoo.github.io/nimconf2024/nimconf2024.html">moigagoo.github.io/nimconf2024/nimconf2024.html</a></p>
<p>Created with <a href="https://github.com/HugoGranstrom/nimiSlides">nimiSlides</a></p>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/reveal.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/highlight/highlight.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/notes/notes.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    Reveal.initialize({
      plugins: [ 
        RevealHighlight,
        RevealNotes,
      ],
    });
  </script>
  </body>
</html>
