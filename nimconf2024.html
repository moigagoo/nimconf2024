<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/reveal.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/theme/black.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/highlight/monokai.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />
  </head>
  <body>
  <div class="reveal">
    <div class="slides">
      <section data-nimib-slide-number="1" >
      <h1>Karax, Kraut, Karkas</h1>
<p>Create compact, fast, and composable frontend and have fun doing it</p>
      <aside class="notes">
  <p>Hi! My name is Constantine, and I've been using Nim as my primary language for hobby development for over a decade.</p>
<p>Today, I'd like to talk about applying Nim in frontend development. My goal is to show that Nim isn't just a viable option for frontend development (this is not news) but an option you can actually compare to the mainstream frameworks like React or Vue in terms of usability, reusability, app size, and programmer's experience.</p>

</aside>
      </section>
      <section data-nimib-slide-number="2" >
      <h2>Key Points</h2>
<ol>
<li>
<p><a href="https://github.com/karaxnim/karax"><strong>Karax</strong></a> is a great framework: fast, lightweight, stable. But it lacks some sugar, namely routing and components.</p>
</li>
<li>
<p><a href="https://github.com/moigagoo/kraut"><strong>Kraut</strong></a> is the missing routing layer for Karax.</p>
<ul>
<li><a href="https://github.com/moigagoo/sauer"><strong>Sauer</strong></a> is a helper CLI tool that makes adding routes trivial.</li>
</ul>
</li>
<li>
<p><a href="https://karkas.nim.town/"><strong>Karkas</strong></a> is the missing component and layouting layer for Karax.</p>
</li>
</ol>
      <aside class="notes">
  <p>First off, Nim has had a React-like framework for ages, called Karax. It's a lean, robust, and mature framework. It produces tiny bundles and is production-ready. However, to compete against React, it lacks some sugar to make a developer's life easier. To me, the most critical ones were routing and components.</p>
<p>This is why I wrote Kraut (along with its companion app Sauer) and Karkasâ€”respectively, the missing routing and component layers for Karax.</p>

</aside>
      </section>
      <section data-nimib-slide-number="3" data-auto-animate >
      <h2>Karax</h2>
      <figure>
<img src="/img/screwdriver.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim in Karax.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="4" data-auto-animate >
      <h2>Karax</h2>
      <ul>
<li>
<p>Virtual DOM implementation</p>
<ul>
<li>Write functions to run in a tight loop to redraw the page</li>
</ul>
</li>
<li>
<p>DSL to build web pages</p>
<ul>
<li>Use familiar tag names without HTML noise</li>
</ul>
</li>
<li>
<p>VNode type that incapsulates a renderable chunk</p>
<ul>
<li>Essentially a component</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim in Karax.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="5" data-auto-animate >
      <h2>Karax</h2>
      <pre><code class="language-nim">include karax/prelude

proc render(routerData: RouterData): VNode =
  buildHtml:
    tdiv:
      h1:
        text &quot;Header&quot;
      p:
        text &quot;You're at &quot; &amp; $routerData.hashPart

setRenderer render
</code></pre>
<pre><code class="language-shell">$ karun app.nim
</code></pre>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim in Karax.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="6" data-auto-animate >
      <h2>Karax</h2>
      <figure>
<img src="/img/karax_app.png" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Let's first talk a bit about Karax and what foundation it offers us.</p>
<p>First, it implements a Virtual DOM, which is the base mechanic behind React and similar frameworks. The Karax implementation is really straightforward: you just define procs that are evaled in a tight loop to redraw the UI. Karax cares about doing it optimally.</p>
<p>Second, Karax gives us a great DSL to actually write pages. It's like React's JSX but instead of being a separate HTML-like language, it's just proper Nim in Karax.</p>
<p>Finally, Karax offers VNode type that represents a renderable chunk. It's basically a component, almost.</p>
<p>This is already enough to build basic apps.</p>
<p>Here's a quick example of a Karax app. And here's what the app looks rendered.</p>
<p>The code is pretty self-explanatory but there's one line I want to draw your attention to. See how we access the hash part. It's just a string. You can imagine how painful it can be to manage multiple routes if you have to parse the string into meaningful chunks all the time. You must handle heading, trailing, and repeating slashes and variable parts manually.</p>

</aside>
      </section>
      <section data-nimib-slide-number="7" data-auto-animate >
      <h2>Kraut</h2>
      <figure>
<img src="/img/screwdriver_with_heads.jpg" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="8" data-auto-animate >
      <h2>Kraut</h2>
      <ul>
<li>
<p>Parser and matcher for Karax's <code>hashPart</code></p>
<ul>
<li>Define routes as string templates matched against the current <code>hashPart</code> value</li>
</ul>
</li>
<li>
<p>Familiar renderer functions from Karax</p>
<ul>
<li>Just return a <code>VNode</code> somehow</li>
</ul>
</li>
<li>
<p>Query and URL param support</p>
<ul>
<li>Access captured context in <code>Context</code> object</li>
</ul>
</li>
</ul>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="9" data-auto-animate >
      <h2>Kraut</h2>
      <pre><code class="language-nim">proc renderUser*(context: Context): VNode =
  buildHtml:
    tdiv:
      p:
        text &quot;User id: &quot; &amp; context.urlParams[&quot;userId&quot;]
</code></pre>
<pre><code class="language-nim">include karax/prelude
import kraut


const
  routes = {
    &quot;/&quot;: renderIndex,
    &quot;/users/&quot;: renderUsers,
    &quot;/users/{userId}/&quot;: renderUser
  }

setRenderer routeRenderer(routes)
</code></pre>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="10" data-auto-animate >
      <h2>Kraut</h2>
      <figure>
<img src="/img/kraut_app.png" alt="">
<figcaption></figcaption>
</figure>
      <aside class="notes">
  <p>Most apps will have more than one location to render. Also, you will often need the same location show different data depending on the URL param. Vanilla Karax doesn't offer route management, and so this is how Kraut was created.</p>
<p>Kraut implements URL parsing and matching. You can define routes as strings to be matched agaist the current URL.</p>
<p>For every route, you define a proc to be executed when this route matches, very simple.</p>
<p>Kraut builds upon Karax's built-in VNode type, meaning that your route rendering procs should just return a VNode.</p>
<p>You can use variable parts in your routes and pass GET-params, Kraut will capture the values and pass them to the renderer.</p>
<p>Here's our previous app but with routes. It renders essentially the same as the previous version but our code is much better now:</p>
<ol>
<li>Our routes are defined as a simple sequence of pairs. You can put your route definition into a separate module and even split it across several modules.</li>
<li>Render proc can now live in a separate module as it receives all its context from Kraut.</li>
<li>We no longer work with raw strings but instead have a nice table of params and their values.</li>
</ol>

</aside>
      </section>
      <section data-nimib-slide-number="11" data-auto-animate >
      <h2>Sauer</h2>
      <figure>
<img src="/img/screwdriver_box.jpg" alt="">
<figcaption></figcaption>
</figure>
      </section>
      <section data-nimib-slide-number="12" data-auto-animate >
      <h2>Sauer</h2>
      <ul>
<li>
<p>Standardized app structure</p>
<ul>
<li>Init project and add pages with shell commands</li>
</ul>
</li>
<li>
<p><strong>Page</strong> abstraction that represents anything that has its own route</p>
<ul>
<li>Focus on business logic</li>
</ul>
</li>
<li>
<p>Global state</p>
<ul>
<li>Access the current page from <code>state</code> module</li>
</ul>
</li>
</ul>
      </section>
      <section data-nimib-slide-number="13" data-auto-animate >
      <h2>Sauer</h2>
      <pre><code class="language-shell">$ sauer init
$ sauer pages new user --route='/users/{userId}/'
</code></pre>
<pre><code class="language-nim">include karax/prelude
import kraut

import ../[pages, state]


proc render*(context: Context): VNode =
  currentPage = Page.user
  document.title = &quot;user&quot;

  buildHtml:
    h1: text &quot;user&quot;
</code></pre>
      </section>
      <section data-nimib-slide-number="14" data-auto-animate >
      <h2>Karkas</h2>
      <figure>
<img src="/img/electric_screwdriver.jpg" alt="">
<figcaption></figcaption>
</figure>
      </section>
      <section data-nimib-slide-number="15" data-auto-animate >
      <h2>Karkas</h2>
      <ul>
<li>
<p>Additional sugar for VNode styling</p>
<ul>
<li>Type less stuff to please the compiler</li>
</ul>
</li>
<li>
<p>Unified approach to components</p>
<ul>
<li>Svelte-like all-in-one components</li>
<li>Layouts are components, too</li>
</ul>
</li>
<li>
<p>Building blocks for layouts</p>
<ul>
<li>Construct pages with flexbox-based primitives</li>
</ul>
</li>
</ul>
      </section>
      <section data-nimib-slide-number="16" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">include karax/prelude
import karkas

import ../[pages, state]


proc navEntry(page: Page, url, caption: string): VNode =
  buildHtml:
    tdiv(style = box() &lt;- {minWidth: &quot;50px&quot;}):
      if state.currentPage != page:
        a(href = k url):
          text k caption
      else:
        text k caption
</code></pre>
      </section>
      <section data-nimib-slide-number="17" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">const
  topPanelStyle = {padding: &quot;10px&quot;, boxShadow: &quot;0 0 10px&quot;}

proc render*(body: VNode): VNode =
  buildHtml:
    tdiv(style = vStack()):
      tdiv(style = topPanel() &lt;- hStack() &lt;- topPanelStyle):
        navEntry(index, &quot;#/&quot;, &quot;Home&quot;)
        navEntry(user, &quot;#/user&quot;, &quot;User&quot;)
      tdiv:
        for node in body:
          node
</code></pre>
      </section>
      <section data-nimib-slide-number="18" data-auto-animate >
      <h2>Karkas</h2>
      <pre><code class="language-nim">include karax/prelude
import kraut

import ../[pages, state, layout]


proc render*(context: Context): VNode =
  currentPage = Page.user
  document.title = &quot;user&quot;

  layout.render buildHtml(tdiv) do:
    h1: text &quot;user&quot;
</code></pre>
      </section>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/reveal.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/highlight/highlight.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/5.0.4/plugin/notes/notes.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script>
    Reveal.initialize({
      plugins: [ 
        RevealHighlight,
        RevealNotes,
      ],
    });
  </script>
  </body>
</html>
